#' All in once for tabular
#'
#' @inheritParams tab_rda
#' @inheritParams tab_arb
#' @inheritParams run_arb
#'
#' @param files_name string used to name all the files needed to process.
#' All files will have the same name, only their extension will be different.
#' @param dir_name string indicated the path of the directory in which to save
#' all the files (.rda, .hst, .txt, .arb, .csv) generated by the function.
#' @param unif_labels boolean, if explanatory variables have to be standardized
#' @param LIMIT numeric, used to choose which variable to merge (if nb_tab_option = 'smart')
#' and split table with a number of row above this limit in order to avoid
#' tauargus failures
#' @param nb_tab_option strategy to follow for choosing variables automatically:
#' \itemize{
#'   \item \code{'min'}: minimize the number of tables;
#'   \item \code{'max'}: maximize the number of tables;
#'   \item \code{'smart'}: minimize the number of tables under the constraint
#'   of their row count.
#' }
#' @param dfs_name name used to write hrc files when reducing dims
#' @param hrc_dir folder used to write hrc files when reducing dims
#' @param sep_dir whether to write hrcfiles in hrc_dir or in existing hrcfiles location
#' @param ... any parameter of the tab_rda, tab_arb or run_arb functions, relevant
#' for the treatment of tabular.
#'
#'
#' @return
#' If output_type equals to 4, then the original tabular is returned with a new
#' column called Status, indicating the status of the cell coming from Tau-Argus :
#' "A" for a primary secret due to frequency rule, "B" for a primary secret due
#' to dominance rule, "D" for secondary secret and "V" for no secret cell.
#'
#' If output_type doesn't equal to 4, then the raw result from tau-argus is returned.
#'
#' @section Standardization of explanatory variables and hierarchies:
#'
#' The boolean argument \code{unif_labels} is useful to
#' prevent some common errors in using Tau-Argus. Indeed, Tau-Argus needs that,
#' within a same level of a hierarchy, the labels have the same number of
#' characters. When the argument is set to TRUE, \code{tab_rtauargus}
#' standardizes the explanatory variables to prevent this issue.
#' Hierarchical explanatory variables (explanatory variables associated to
#' a hrc file) are then modified in the tabular data and an another hrc file is
#' created to be relevant with the tabular. In the output, these modifications
#' are removed.
#'
#' @examples
#'\dontrun{
#' library(rtauargus)
#' #Please don't forget to specify the localisation of Tau-Argus in your computer
#' options(
#'   rtauargus.tauargus_exe =
#'     "Y:/Logiciels/TauArgus/TauArgus4.2.3/TauArgus.exe"
#' )
#'
#' res_dim4 <- tab_rtauargus4(
#'   tabular = datatest1,
#'   files_name = "datatest1",
#'   dir_name = "tauargus_files",
#'   explanatory_vars = c("A10", "treff","type_distrib","cj"),
#'   totcode = c(A10 = "Total", treff = "Total",type_distrib = "Total",cj = "Total"),
#'   secret_var = "is_secret_prim",
#'   value = "pizzas_tot_abs",
#'   freq = "nb_obs_rnd",
#'   verbose = TRUE,
#'   nb_tab_option = "min",
#'   verbose = TRUE
#' )
#'
#' # With a data of 5 variables
#'
#' expl_vars <- c("A10", "treff","type_distrib","cj","nuts1")
#'
#' res_dim5 <- tab_rtauargus4(
#'   tabular = datatest2,
#'   files_name = "datatest2",
#'   dir_name = "tauargus_files",
#'   explanatory_vars = expl_vars,
#'   totcode = setNames(rep("Total", 5), expl_vars),
#'   secret_var = "is_secret_prim",
#'   value = "pizzas_tot_abs",
#'   freq = "nb_obs_rnd",
#'   verbose = TRUE,
#'   nb_tab_option = "min", # split into the minimum of tables.
#'   verbose = TRUE,
#'   suppress = "GH(1,100)" # We use hyerpcube to save time.
#' )
#' }
#' @export
tab_rtauargus4 <- function(
    tabular,
    files_name = NULL,
    dir_name,
    explanatory_vars,
    totcode = getOption("rtauargus.totcode"),
    hrc = NULL,
    secret_var,
    secret_no_pl = NULL,
    cost_var = NULL,
    value = "value",
    freq = "freq",
    ip = 10,
    suppress = "MOD(1,5,1,0,0)",
    safety_rules = paste0("MAN(",ip,")"),
    nb_tab_option = "smart",
    LIMIT = 14700,
    dfs_name = 'tab',
    ...
){

  .dots = list(...)

  hrc_path <- file.path(dir_name, "hrc")
  if (!dir.exists(hrc_path)){
    dir.create(hrc_path)
  }

  # TODO:
  # deleting created hrc files at the end of the function ?

  # Reduce dims for 4 or 5 dimensions table
  if (length(explanatory_vars) %in% c(4, 5)) {

    cat("\nReducing dims...\n",dfs_name,"\n\n")

    list_tables <- reduce_dims(
      dfs = tabular,
      dfs_name = dfs_name,
      totcode = totcode,
      hrcfiles = hrc,
      hrc_dir = hrc_path,
      nb_tab_option = nb_tab_option,
      LIMIT = LIMIT,
      over_split = TRUE,
      verbose = TRUE, # to generalize later
      sep_dir = TRUE
    )

    # TODO : Update the arguments by using the ... argument

    # params <- param_function(tab_multi_manager, .dots)
    # params$list_tables = list_tables$tabs
    # params$dir_name = dir_name
    # params$list_explanatory_vars = list_tables$vars

    # params$totcode = list_tables$totcode
    # params$alt_totcode = list_tables$alt_totcode
    # params$hrc = list_tables$hrc
    # params$alt_hrc = list_tables$alt_hrc

    # params$secret_var = secret_var
    # params$secret_no_pl = secret_no_pl
    # params$cost_var = cost_var
    # params$value = value
    # params$freq = freq

    # if(is.null(ip)){
    #   if(!"safety_rules" %in% names(params)){
    #     stop("Either ip or safety_rules has to be set.")
    #   }
    # }else{
    #   params$safety_rules = paste0("MAN(",ip,")")
    # }

    # params$ip = ip
    # params$suppress = suppress
    # params$show_batch_console = FALSE
    # params$output_type = 4
    # params$output_options = ""
    # params$unif_labels = TRUE
    # params$separator = ","
    # params$verbose = FALSE

    # do.call("tab_multi_manager", params)

    params_multi <- formals(fun = "tab_multi_manager")
    params_multi <- params_multi[1:(length(params_multi)-1)]
    call <- sys.call(); call[[1]] <- as.name('list')
    new_params <- eval.parent(call)

    for(param in intersect(names(params_multi), names(new_params))){
      params_multi[[param]] <- new_params[[param]]
    }

    params_multi$list_tables = list_tables$tabs
    params_multi$list_explanatory_vars = list_tables$vars
    params_multi$hrc = list_tables$hrc
    params_multi$totcode = list_tables$totcode
    params_multi$alt_hrc = list_tables$alt_hrc
    params_multi$alt_totcode = list_tables$alt_totcode

    masq_list <- do.call("tab_multi_manager", params_multi)
    # (
    #   list_tables = list_tables$tabs,
    #   list_explanatory_vars = list_tables$vars ,
    #   dir_name = dir_name,
    #   hrc = list_tables$hrc,
    #   totcode = list_tables$totcode,
    #   alt_hrc = list_tables$alt_hrc,
    #   alt_totcode = list_tables$alt_totcode,
    #   value = value,
    #   freq = freq,
    #   secret_var = secret_var,
    #   suppress = suppress
    # )

    result <- restore_format(masq_list, list_tables)

    return(result)
  } else {
    stop("Do not use table with more than 5 dimensions.
         Split_tab = TRUE is not compatible with these large tables.")
  }
}
