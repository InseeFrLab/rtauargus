 # Fonction qui ajuste la taille d'une chaîne de caractères en ajoutant
 # un même caractère devant pour atteindre une taille souhaitée
 # @param char string chaîne de caractères à modifier
 # @param cible_char integer - longueur de la chaîne souhaitée
 # @param add_char caractère à ajouter
 # @return chaîne de caractère
trans_var_pour_tau_argus <- function(char='monchar', cible_char=12, add_char='*'){
  diff <- cible_char - nchar(char)
  if(diff > 0)
    char = paste0(paste0(rep(add_char,diff), collapse=''),char)
  return(char)
}

# Fonction vectorisée de la précédente. Cette fonction est à privilégier pour
# une utilisation sur un vecteur, une colonne d'un dataframe par exemple.
#
# @param char character vector
# @param cible_char integer - longueur de la chaîne souhaitée
# @param add_char caractère à ajouter
#
# @return character vector
v_trans_var_pour_tau_argus <- Vectorize(trans_var_pour_tau_argus, vectorize.args = 'char')

# Fonction vectorisée de la précédente. Cette fonction est à privilégier pour
# une utilisation sur un vecteur, une colonne d'un dataframe par exemple.
#
# @param char character vector - vecteur à modifier
#
# @return character vector
rev_var_pour_tau_argus <- function(char='**monchar', del_char='*'){
  if(del_char %in% c('*','+','_',' ')){
    gsub(paste0("[",del_char,"]"),'',char)
  }else gsub(del_char, '', char)
}



#' All in once for tabular
#'
#' @inheritParams tab_rda
#' @inheritParams tab_arb
#' @inheritParams run_arb
#'
#' @param files_name string used to name all the files needed to process.
#' All files will have the same name, only their extension will be different.
#' @param dir_name string indicated the path of the directory in which to save
#' all the files (.rda, .hst, .txt, .arb, .csv) generated by the function.
#' @param unif_hrc boolean, if hrc files have to be standardized (especially for internal use)
#' @param unif_expl boolean, if explanatory variables have to be standardized (especially for internal use)
#' @param ... any parameter of the tab_rda, tab_arb or run_arb functions, relevant
#' for the treatment of tabular.
#'
#' @return
#' If output_type equals to 4, then the original tabular is returned with a new
#' column called Status, indicating the status of the cell coming from Tau-Argus :
#' "A" for a primary secret due to frequency rule, "B" for a primary secret due
#' to dominance rule, "D" for secondary secret and "V" for no secret cell.
#'
#' If output_type doesn't equal to 4, then the raw result from tau-argus is returned.
#'
#' @section Standardization of explanatory variables and hierarchies:
#'
#' The two boolean arguments \code{unif_hrc} and \code{unif_expl} are useful to
#' prevent some common errors in using Tau-Argus. Indeed, Tau-Argus needs that,
#' within a same level of a hierarchy, the labels have the same number of
#' characters. When the two arguments are set to TRUE, \code{tab_rtauargus}
#' standardizes the explanatory variables to prevent this issue.
#' For hierarchical explanatory variables (explanatory variables associated to
#' a hrc file) are then modified in the tabular data and an another hrc file is
#' created to be relevant with the tabular. In the output, these modifications
#' are removed. For non hierarchical explanatory variables,
#' only the tabular is modified.
#'
#' @examples
#'\dontrun{
#' library(dplyr)
#' data(turnover_act_size)
#'
#' # Prepare data with primary secret ----
#' turnover_act_size <- turnover_act_size %>%
#'   mutate(
#'     is_secret_freq = N_OBS > 0 & N_OBS < 3,
#'     is_secret_dom = ifelse(MAX == 0, FALSE, MAX/TOT>0.85),
#'     is_secret_prim = is_secret_freq | is_secret_dom
#'   )
#'
#' # Make hrc file of business sectors ----
#' data(activity_corr_table)
#' hrc_file_activity <- activity_corr_table %>%
#'   write_hrc2(file_name = "hrc/activity")
#'
#' # Compute the secondary secret ----
#' options(
#'   rtauargus.tauargus_exe =
#'     "Y:/Logiciels/TauArgus/TauArgus4.2.2b1/TauArgus.exe"
#' )
#'
#' res <- tab_rtauargus(
#'   tabular = turnover_act_size,
#'   files_name = "turn_act_size",
#'   dir_name = "tauargus_files",
#'   explanatory_vars = c("ACTIVITY", "SIZE"),
#'   hrc = c(ACTIVITY = hrc_file_activity),
#'   totcode = c(ACTIVITY = "Total", SIZE = "Total"),
#'   secret_var = "is_secret_prim",
#'   value = "TOT",
#'   freq = "N_OBS",
#'   verbose = FALSE
#' )
#' }
#' @export
tab_rtauargus <- function(
    tabular,
    files_name = NULL,
    dir_name = NULL,
    explanatory_vars,
    totcode = getOption("rtauargus.totcode"),
    hrc = NULL,
    secret_var = NULL,
    cost_var = NULL,
    value = "value",
    freq = "freq",
    maxscore = NULL,
    safety_rules = "MAN(10)",
    suppress = "MOD(1,5,1,0,0)",
    show_batch_console = FALSE,
    output_type = 4,
    output_options = "",
    unif_hrc = TRUE,
    unif_expl = TRUE,
    ...
){

  .dots <- list(...)

  ## 0. CONFLITS PARAMETRES .................

  # tabular not a data.frame
  if(!is.data.frame(tabular)){
    stop("tabular has to be a dataframe.")
  }
  if(any(!explanatory_vars %in% names(tabular))){
    stop("At least one of the explanatory vars is not a tabular's column name")
  }
  if(any(!c(value, freq) %in% names(tabular))){
    stop(paste0(value, " or ", freq, " is not a tabular's column name"))
  }
  if(!is.null(maxscore)){
    if(!maxscore %in% names(tabular)){
      stop(paste0(maxscore, " is not a tabular's column name"))
    }
  }
  if(!is.null(cost_var)){
    if(!cost_var %in% names(tabular)){
      stop(paste0(cost_var, " is not a tabular's column name"))
    }
  }
  if(!is.null(secret_var)){
    if(!secret_var %in% names(tabular)){
      stop(paste0(secret_var, " is not a tabular's column name"))
    }
  }
  if(length(totcode) < length(explanatory_vars)){
    stop("totcode must have the same length as explanatory_vars")
  }
  if(length(names(totcode)) < length(explanatory_vars)){
    names(totcode) <- explanatory_vars
  }

  if(is.null(files_name)) files_name <- paste0("tau_argus_file_", format.Date(Sys.time(), format = '%Y_%m_%d_%H:%M:%S'))
  if(is.null(dir_name)) dir_name <- getwd()


  ## 1. TAB_RDA  .....................
  tabular_original <- tabular
  # uniformisation des chaines de caractères des variables catégorielles, hors total
  # tabular ......................
  if(unif_expl){
    trans_expl <- sapply(
      explanatory_vars,
      function(var){
        col <- tabular[[var]]
        max_char = max(nchar( col[col != totcode[[var]]]))
        ifelse(col == totcode[[var]], col, v_trans_var_pour_tau_argus(col, cible_char = max_char))
      },
      simplify = TRUE
    )
    tabular <- cbind.data.frame(
      trans_expl,
      tabular[,!names(tabular) %in% explanatory_vars]
    )
  }
  if(unif_hrc & (length(hrc) > 0)){
    # fichiers hrc ..................
    hrc_unif <- sapply(
      names(hrc),
      function(var_name){
        file <- hrc[[var_name]]
        df <- read.table(file)

        v_gsub <- Vectorize(gsub, vectorize.args = c("pattern", "x"))
        df$aro <- unlist(regmatches(df$V1, gregexpr("^@*", df$V1)))
        df$lab <- v_gsub(df$aro, "", df$V1)

        df <- df[df$lab != totcode[[var_name]],]
        max_char = max(nchar(df$lab))
        df$lab <- v_trans_var_pour_tau_argus(df$lab, max_char)
        df$unif <- paste0(df$aro,df$lab)

        name <- gsub(".hrc$", "_unif.hrc", file)

        write.table(
          x = as.data.frame(df$unif),
          file = name,
          quote = FALSE,
          row.names = FALSE,
          col.names = FALSE,
          sep = "",
          eol = "\n"
        )
        print(paste0(name, " has been created"))
        name
      }
    )
    hrc <- hrc_unif
  }

  # parametres
  param_tab_rda <- param_function(tab_rda, .dots)
  param_tab_rda$tabular <- tabular
  param_tab_rda$tab_filename <- file.path(dir_name, paste0(files_name, ".tab"))
  param_tab_rda$rda_filename <- file.path(dir_name, paste0(files_name, ".rda"))
  param_tab_rda$hst_filename <- if(is.null(secret_var) & is.null(cost_var)) NULL else file.path(dir_name, paste0(files_name, ".hst"))
  param_tab_rda$explanatory_vars <- explanatory_vars
  param_tab_rda$hrc <- hrc

  param_tab_rda$totcode <- totcode
  param_tab_rda$secret_var <- secret_var
  param_tab_rda$cost_var <- cost_var
  param_tab_rda$value <- value
  param_tab_rda$freq <- freq
  param_tab_rda$maxscore <- maxscore

  # appel (+ récuperation noms tab hst et rda)
  input <- do.call(tab_rda, param_tab_rda)


  ## 2. TAB_ARB .........................

  # parametres
  param_arb <- param_function(tab_arb, .dots)
  param_arb$tab_filename <- input$tab_filename
  param_arb$rda_filename <- input$rda_filename
  param_arb$hst_filename <- input$hst_filename
  param_arb$arb_filename <- file.path(dir_name, paste0(files_name, ".arb"))
  param_arb$output_names <- file.path(dir_name, paste0(files_name, ".csv"))
  #TODO : generaliser le choix de l'extension
  param_arb$output_type <- output_type
  param_arb$output_options <- output_options
  param_arb$explanatory_vars <- explanatory_vars
  param_arb$value <- value
  param_arb$safety_rules <- safety_rules
  param_arb$suppress <- suppress

  # appel (+ récupération nom batch)
  batch <- do.call(tab_arb, param_arb)

  ## 3. RUN_ARB ...........................

  # parametres
  param_run0 <- param_function(run_arb, .dots)
  param_system <- param_function(system, .dots)
  param_run <- c(param_run0, param_system)
  param_run$arb_filename <- param_arb$arb_filename
  param_run$logbook <- file.path(dir_name, paste0(files_name, ".txt"))
  param_run$is_tabular <- TRUE
  param_run$show_batch_console <- show_batch_console

  # appel
  res <- do.call(run_arb, param_run)

  # RESULTAT .............................
  if(output_type == 4){

    res <- read.csv(
      param_arb$output_names,
      header = FALSE,
      col.names = c(explanatory_vars, value, freq, "Status","Dom"),
      colClasses = c(rep("character", length(explanatory_vars)), rep("numeric",2), "character", "numeric"),
      stringsAsFactors = FALSE,
      na.strings = ""
    )
    res <- cbind.data.frame(
      apply(res[,explanatory_vars,drop=FALSE], 2, rev_var_pour_tau_argus),
      res[, !names(res) %in% explanatory_vars]
    )
    mask <- merge(tabular_original, res[,c(explanatory_vars,"Status")], by = explanatory_vars, all = TRUE)


    write.csv(
      res,
      file = param_arb$output_names,
      row.names = FALSE
    )

    return(mask)

  }else{
    return(res)
  }

}

#' Wrapper of tab_rtauargus adapted for \code{tab_multi_manager} function.
#'
#' @inheritParams tab_rtauargus
#' @param ip Interval Protection Level (10 by default)
#' @param ... Other arguments of \code{tab_rtauargus} function
#'
#' @return
#' The original tabular is returned with a new
#' column called Status, indicating the status of the cell coming from Tau-Argus :
#' "A" for a primary secret due to frequency rule, "B" for a primary secret due
#' to dominance rule, "D" for secondary secret and "V" for no secret cell.
#'
#' @seealso \code{tab_rtauargus}
#'
#' @export
#'
#' @examples
#'\dontrun{
#' library(dplyr)
#' data(turnover_act_size)
#'
#' # Prepare data with primary secret ----
#' turnover_act_size <- turnover_act_size %>%
#'   mutate(
#'     is_secret_freq = N_OBS > 0 & N_OBS < 3,
#'     is_secret_dom = ifelse(MAX == 0, FALSE, MAX/TOT>0.85),
#'     is_secret_prim = is_secret_freq | is_secret_dom
#'   )
#'
#' # Make hrc file of business sectors ----
#' data(activity_corr_table)
#' hrc_file_activity <- activity_corr_table %>%
#'   write_hrc2(file_name = "hrc/activity")
#'
#' # Compute the secondary secret ----
#' options(
#'   rtauargus.tauargus_exe =
#'     "Y:/Logiciels/TauArgus/TauArgus4.2.2b1/TauArgus.exe"
#' )
#'
#' res <- tab_rtauargus2(
#'   tabular = turnover_act_size,
#'   files_name = "turn_act_size",
#'   dir_name = "tauargus_files",
#'   explanatory_vars = c("ACTIVITY", "SIZE"),
#'   hrc = c(ACTIVITY = hrc_file_activity),
#'   totcode = c(ACTIVITY = "Total", SIZE = "Total"),
#'   secret_var = "is_secret_prim",
#'   value = "TOT",
#'   freq = "N_OBS"
#' )
#' }
tab_rtauargus2 <- function(
    tabular,
    files_name = NULL,
    dir_name = NULL,
    explanatory_vars,
    totcode,
    hrc = NULL,
    secret_var = NULL,
    cost_var = NULL,
    value = "value",
    freq = "freq",
    ip = 10,
    suppress = "MOD(1,5,1,0,0)",
    ...
){
  .dots = list(...)

  params <- param_function(tab_rtauargus, .dots)
  params$tabular = tabular
  params$files_name = files_name
  params$dir_name = dir_name
  params$explanatory_vars = explanatory_vars
  params$totcode = totcode
  params$hrc = hrc
  params$secret_var = secret_var
  params$cost_var = cost_var
  params$value = value
  params$freq = freq
  if(is.null(ip)){
    if(!"safety_rules" %in% names(params)){
      stop("Either ip or safety_rules has to be set.")
    }
  }else{
    params$safety_rules = paste0("MAN(",ip,")")
  }
  params$suppress = suppress
  params$show_batch_console = FALSE
  params$output_type = 4
  params$output_options = ""
  params$unif_hrc = TRUE
  params$unif_expl = TRUE
  params$separator = ","
  params$verbose = FALSE

  do.call("tab_rtauargus", params)

}
